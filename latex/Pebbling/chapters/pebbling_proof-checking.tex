\section{Pebbling and Proof Processing}
\label{sec:pebblingchecking}

The problem of processing a proof with minimal memory consumption is analogous to the problem of finding a pebbling strategy with minimal pebbling number.
Proof processing might be checking its correctness, manipulating it or extracting information from it.
In Section \ref{sec:pebbling-game} it was pointed out that strategies with minimal pebbling numbers may require to play exponentially many rounds.
Every round of the game corresponds to an I/O operation and if the action of the player is to pebble a node also the processing of it.
The goal of proof compression is to reduce the hardness of proof processing, therefore requiring exponentially I/O operations and processing steps is not a viable option.
That is the reason why we chose the static pebbling game for our purpose.
In the static pebbling game the number of rounds is essentially the number of nodes.

In order to process a node, the results of processing its premises are used and therefore have to be stored in memory.
For example to check the correctness of a node, the correctness of its premises is required.
A node is considered to be correct if all its premises are correct and if it has premises, then the conclusion of the node is a resolvent of the conclusions of its premises.
The requirement of having premises in memory corresponds to rule \ref{rule:premises} of the static pebbling game. 
Processing a node and I/O operations are typically more expensive than extra memory consumption, therefore in our setting every node can be processed only once, which corresponds to rule \ref{rule:onlyonce}.
A node that has been processed can be removed from memory, which corresponds to rule \ref{rule:unpebbling}.
Note that removing a node and its results too early in combination with \ref{rule:onlyonce} makes it impossible to process the whole proof.
The best moment for removing a node from memory is canonical, as shown later in this chapter.


The following definition allows us to relate pebbling strategies with orderings of nodes.

\begin{definition}[Topological Order]
\label{def:topological-order}
A topological order of a proof $\varphi$ is a total order relation $\prec$ on $\Vertices{\varphi}$, such that 
$\text{for all } \n \in \Vertices{\varphi} \text{, for all } p \in \Premises{\n}{\varphi}:
p \prec v$.
A pebbling strategy $\sigma = (\sigma_1,\ldots,\sigma_n)$ \emph{respects} a topological order $\prec$ if $j < i$ \emph{iff} $\sigma_j \prec \sigma_i$.
\qed
\end{definition}

A topological order $\prec$ can be represented as a sequence $(v_1,\dots,v_n)$ of proof nodes, by defining $\prec \defeq \{(v_i,v_j) \mid 1 \leq i < j \leq n\}$. 
This sequence can be interpreted as a particular pebbling strategy, played on the DAG that corresponds to the proof.
The requirement of topological orders to order premises higher than their children corresponds to rule \ref{rule:premises} of the static pebbling game.
The antisymmetry together with the fact that $V = \{v_1,\dots,v_n\}$ corresponds to \ref{rule:onlyonce}.
The only thing missing are the unpebbling moves.
The following theorem states that unpebbling moves are given implicit, when the goal is to find strategies with small pebbling numbers.

%TODO: remove the ugly k
\begin{definition}[Canonical Topological Pebbling Strategy]
The \emph{canonical topological pebbling strategy} $\sigma$ for a proof $\varphi$, its root node $s$ and a topological order $\prec$, represented as a sequence $(v_1,\dots,v_n)$ is recursively:
\begin{align*}
\sigma_1 &= v_1\\
\sigma_i &= v_j\text{ such that }\Bigg\{
\begin{array}{l}
	\text{for all }v \in \Premises{v_j}{\varphi}:\text{ there exists }k < i, \sigma_k = v \\
	\text{or }j = min(k \mid \text{ for all }l < i: \sigma_l \neq v_k
\end{array}
\end{align*}
\qed
\end{definition}

The following theorem shows that unpebbling moves can be omitted from strategies for the static pebbling game, when the goal is to produce strategies with low pebbling numbers.

\begin{theorem}
\label{theorem:canonical}
The canonical pebbling strategy has the minimum pebbling number among all pebbling strategies that respect the topological order $\prec$.
\end{theorem}
\begin{proof} (Sketch)
All the pebbling strategies respecting $\prec$ differ only w.r.t. their unpebbling moves.
Consider the unpebbling of an arbitrary node $v$ in the canonical pebbling strategy. Unpebbling it later could only possibly increase the pebble number. To reduce the pebble number, $v$ would have to be unpebbled earlier than some preceding pebbling move. But, by definition of canonical pebbling strategy, the immediately preceding pebbling move pebbles the last child of $v$ w.r.t. $\prec$. Therefore, unpebbling $v$ earlier would make it impossible for its last child to be pebbled later without violating the rules of the game.
\qed
\end{proof}

\noindent
Theorem \ref{theorem:canonical} shows that, in the version of the pebbling game considered here, the problem of finding a strategy with a low pebble number can be reduced to the problem of finding a topological order whose canonical strategy has a low pebble number. Unpebbling moves can be omitted, because the optimal moment to unpebble a node is immediately after its last child has been pebbled.

Assuming that nodes are approximately of the same size, the maximum memory needed to check a proof is proportional to the maximum number of nodes that have to be kept in memory while checking the proof according to a given topological order. Thus memory consumption can be estimated by the following measure:

\newcommand{\pspace}[2]{s(#1,#2)}
\begin{definition}[Space]
\label{def:space measure}
The \emph{space} $\pspace{\varphi}{\prec}$ 
of a proof $\varphi$ and a topological order $\prec$ is the pebbling number of the canonical topological pebbling strategy of $\varphi$, its root and $\prec$.
\qed
\end{definition}

\noindent
The problem of compressing the space of a proof $\varphi$ and a topological order $\prec$ is the problem of finding another topological order $\prec'$ such that $\pspace{\varphi}{\prec'} < \pspace{\varphi}{\prec}$. The following theorem shows that the number of possible topological orders is very large; hence, enumeration is not a feasible option when trying to find a good topological order.

\begin{theorem}
\label{theorem:enumeration}
There is a sequence of proofs $(\varphi_1,\ldots,\varphi_m,\ldots)$ such that $\plength{\varphi_m} \in O(m)$ and $|T(\varphi_m)| \in \Omega(m!)$, where $T(\varphi_m)$ is the set of possible topological orders for $\varphi_m$.
\end{theorem}
\begin{proof}
Let $\varphi_m$ be a perfect binary tree with $m$ axioms. Clearly, $\plength{\varphi_m} = 2m-1$.
Let $(\n_1,\ldots,\n_n)$ be a topological order for $\varphi_m$. 
Let $\Axioms{\varphi} = \{\n_{k_1},\ldots,\n_{k_m}\}$, then $(\n_{k_1},\ldots,\n_{k_m},\n_{l_1},\ldots,\n_{l_{n-m}})$, where $(l_1,\ldots,l_{n-m}) = (1,\ldots,n) \setminus (k_1,\ldots,k_m)$, is a topological order as well. 
Likewise, $(\n_{\pi({k_1})},\ldots,\n_{\pi({k_m})},\n_{l_1},\ldots,\n_{l_{n-m}})$ is a topological order, for every permutation $\pi$ of $\{k_1,\ldots,k_m\}$. There are $m!$ such permutations, so the overall number of topological orders is at least factorial in $m$ (and also in $n$).
\end{proof}

