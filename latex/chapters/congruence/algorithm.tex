\section*{Congruence closure algorithm}
\label{sec:algorithm}
\SetKwInput{KwGlobal}{Global}
\SetKw{KwInvariant}{Invariant}
\SetKw{KwAssert}{Assert}

In this section, we will present a congruence closure algorithm that is able to produce explanations.
The algorithm is a mix of the approaches of the algorithms presented in \cite{Fontaine2004} and \cite{Nieuwenhuis2005,Nieuwenhuis2007}.
The basic structure of the algorithm is inherited from \cite{Fontaine2004}, which itself inherits its structure from the algorithm of Nelson and Oppen \cite{Nelson1980}.
The technique to store and deduce equations of non constant terms is inspired from \cite{Nieuwenhuis2005,Nieuwenhuis2007}.
Additionally the proof forest structure described below, was proposed by \cite{Nieuwenhuis2005,Nieuwenhuis2007}.

\subsection*{Preliminaries}

Our congruence closure algorithm operates on curried terms.
Curried terms use a single binary function symbol to represent general terms.
More formally let $\mathcal{F}$ be a finite set of functions with a designated binary function symbol $f \in \mathcal{F}$ and let every other function symbol in $\mathcal{F}$ be a constant.
A term w.r.t. a signature of this form is called a \emph{curried term}.

It is possible to uniquely translate a general set of terms $\mathcal{T}^{\Sigma}$ with signature $\Sigma = \langle \mathcal{F},arity \rangle$ into a set of curried terms $\mathcal{T'}^{\Sigma'}$.
$\Sigma'$ is obtained from $\Sigma$ by setting $arity$ to zero for every function symbol in $\mathcal{F}$ and introducing the designated binary function symbol $f$ to $\mathcal{F}$.
The translation of a term $t \in \mathcal{T}^{\Sigma}$ is given in terms of the function $curry$.

$$
curry(t) = \Big\{
\begin{array}{ll}
	t & \text{ if } t \text{ is a constant }\\
	f(\ldots (f(f(g,curry(t_1)),curry(t_2)))\ldots,curry(t_n)) &\text{ if } t = g(t_1,\ldots, t_n)
\end{array}
$$

The idea of currying was introduced by M. Sch\"onfinkel \cite{Schoenfinkel1924} in 1924 and independently by Haskell B. Curry \cite{Curry1958} in 1958, who also lends his name to the concept.
Currying is not restricted to terms.
The general indea is to translate functions of type $A \times B \rightarrow C$ into functions of type $A \rightarrow B \rightarrow C$.
There is a close relation between currying and lambda calculus \cite{Church1936}.
Lambda calculus uses a single binary function $\lambda$.
Its arguments can either be elements of some set or again lambda terms.
For an introduction to lambda calculus, including currying in terms of lambda calculus and its relation to functional programming, see \cite{Barendregt1997}.

The benefit of working with curried terms is an easier and cleaner congruence closure algorithm that runs in optimal time $O(n \log(n))$.

Recently so called abstract congruence closure algorithms have been proposed and shown to be more efficient than traditional approaches \cite{Bachmair2000}.
The idea of abstract congruence closure is to introduce new constants for non constant terms.
Doing so, all of equations the algorithm has to take into account are of the form $c = d$ and $c = f(a,b)$, where $a,b,c,d$ are constants.
This replaces tedious preprocessing steps, for example transformation to a graph of outdegree 2 \cite{Downey1980},that are necessary for other algorithms to achieve the optimal running time.

Our method is does not employ the idea of abstract congruence closure.
We found that using currying is enough to obtain an algorithm with optimal running time and no tedious preprocessing steps.
The reason why we did not go for abstract congruence closure is, that we do not want to have the overhead of introducing and eliminating fresh constants.
In the context of proof compression, our congruence closure algorithm will be applied to relatively small instances very often.
We could introduce the extra constants for the whole proof before processing, but would still have to remove them from explanations every time we produce a new subproof.
It would be interesting to investigate, whether our intuition in that regard is right, or if it pays off to deal with extra constants.

Comming back to the explanation producing congruence closure algorithms that inspired ours, \cite{Nieuwenhuis2005,Nieuwenhuis2007} describes an abstract one using currying.
\cite{Fontaine2004} uses a traditional algorithm without currying and extra constants.
Our algorithm is a middle ground between them.

\subsection*{Congruence structure}

A \emph{congruence structure} for set of terms $\mathcal{T}$ is a collection of the following data structures.

\begin{itemize}
	%\item Congruence structure $\langle \mathcal{T}, r,[.], lN, rN, l \rangle$
	\item Representative $r: \mathcal{T} \rightarrow \mathcal{T}$
	\item Congruence class $[.]: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Left neighbours $lN: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Right neighbours $rN: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Lookup table $l: \mathcal{T} \times \mathcal{T} \rightarrow \mathcal{T}$
	\item Congruence graph $g$
	\item Queue $\mathcal{Q}$ of type $\mathcal{T} \times \mathcal{T}$
	\item Current explanations $\mathcal{M}: \mathcal{T} \times \mathcal{T} \rightarrow \mathcal{E}$
\end{itemize}

We call the unique congruence structure for $\mathcal{T} = \emptyset$ the \emph{empty congruence structure}.
Initially $\mathcal{T}$ is empty.
The method \texttt{addNode} enlarges the set of terms.
The updates of $\mathcal{T}$ are not outlined explicitly, but are understood to happen implicitly.
The algorithms below iteratively create new congruence structures from the empty one.
The methods allow to implement congruence structure immutable, see Section \ref{TODO} for details on immutability.

\subsection*{Algorithms}

\input{chapters/congruence/algorithms/addnode}

\input{chapters/congruence/algorithms/addequation}

\input{chapters/congruence/algorithms/merge}

\input{chapters/congruence/algorithms/lazyinsert}

\input{chapters/congruence/algorithms/lazyupdate}

\input{chapters/congruence/algorithms/union}

\begin{invariant}[Congruence class]

For every $s \in \mathcal{T}$, $s \in [r(s)]$
\label{invar:class}
\end{invariant}

\begin{proof}

Clearly the invariant is true when intializing $[s]$ in line \ref{initclass} of addNode.

The only other point in the code that changes $[s]$ is line \ref{changeclass} of union.
Let $v$ and $u$ be the arguments of a call to union.
If $r(s) \neq r(v)$ before the union, then $r(s)$ is not changed and so is $[s]$.
If $r(s) = r(v)$ before the union, then line \ref{changerep} changes $r(s)$ to $r(u)$.
Since by induction $s \in [r(v)]$ before the union, after line \ref{changeclass} holds $s \in [r(u)]$.

\end{proof}

\begin{assertion}[Merge changes]

For $s \in \mathcal{T}$ let $r(s)$ and $r'(s)$ be the representative of $s$ before and after a call to $merge(u,v,eq)$.
Let $S$ be the set of subterms of $s$.
If $r(s) \neq r'(s)$ then there is $t \in sub(s)$ such that $r(t) = r(u)$ or $r(t) = r(v)$.

\end{assertion}

\begin{proof}

Only union changes the representatives after they were initialized.
Union deduces new equations for terms in the lookup table.

\end{proof}

\begin{invariant}[Lookup]

For every congruence structure and for every term $t \in l(\mathcal{T}\times \mathcal{T})$, $t$ is of the form $f(a,b)$ and there are unique terms $u,v$ such that $r(a) = u$, $r(b) = v$ such that $l(u,v) = f(a,b)$

\end{invariant}

\begin{proof}

The values of $l$ are set in line \ref{initl} of \texttt{addNode} and lines \ref{changel1}, \ref{changel2} of \texttt{union}. 
Once they have been set, they do not change anymore.
The correctness of the invariant in line \ref{initl} of \texttt{addNode} follows from Invariant \ref{invar:class}.
Therefore to prove the correctness of the invariant, we have to show that the representatives are updated correctly in a call to \texttt{union} in which lines \ref{changel1}, \ref{changel2} are executed.
Therefore to prove the correctness of the invariant, we have to show that if \texttt{union} initializes $l$
Let $u,v,a,b$ be terms such that $l(u,v) = f(a,b)$.
Suppose that before the union $r(a) = u$ and $r(b) = v$.

Therefore to prove the correctness of the invariant, we have to show that the change of representatives in line \ref{changerep} of \texttt{union} preserves it.

We have to show that 

\end{proof}


\begin{invariant}[Neighbours]

For every $s \in \mathcal{T}$, every $t_r \in rN(r(s))$ and $t_l \in lN(r(s))$, $l$ is defined for $(s,r(t_r))$ and $(r(t_l),s)$.

\end{invariant}

\begin{proposition}[Neighbours holds]

The Neighbours invariant holds in line \ref{invariant:neig_add} of addNode and line \ref{invariant:neig_union} of union.

\end{proposition}

\begin{proof}

For addNode either the 

\end{proof}

\begin{proposition}[Correctness]

Let $\mathcal{C}$ be the congruence structure obtained by adding equations $E = e_1, \ldots, e_n$ to the empty congruence structure.
For every $s,t \in \mathcal{T}$: $E \models s = t$ if and only if $r(s) = r(t)$.

\end{proposition}

\begin{proof}

by induction on n

n = 1

nodes added, no deductions; lN,rN of compound terms empty 

n -> n+1

only union changes datastructs,
only structs of subterms of input eq are changed + representative of same class

\end{proof}

\begin{proposition}[Lookup table]

Let $\mathcal{C} = \langle \mathcal{T},r,[.], lN, rN, l \rangle$ be the congruence structure obtained after adding equations $E = e_1, \ldots, e_n$ to the empty congruence structure.
For every $s,t \in \mathcal{T}: t \in lN(r(s))$ if and only if $l$ is defined for $(r(t),r(s))$.

\end{proposition}

\subsection*{Congruence graph}

To produce explanations, the input equations together with deduced equalities have to be stored in some data structure that supports the production of explanations.
We support two different data structures for this purpose.
Both structures store equations in a labeled graph.
A path in a congruence graph is a sequence of undirected, unweighted, labeled edges in the underlying graph.
The set of labels for both types of graphs is the set of extended equations $\mathcal{E}$.

\begin{invariant}[Paths]

For terms $s, t$ such that $s \neq t$ and a congruence structure with representative function $r$ holds if $r(s) = r(t)$ then there is a path in the congruence graph of the structure between $s$ and $t$

\end{invariant}

\begin{invariant}[Insert]

For every edge in a congruence structure between vertices $u,v$ with label $null$, 
there are $a,b,c,d \in \mathcal{T}$ such that $u = f(a,b)$, $v = f(c,d)$, 
there are paths in the underlying graphs between $a$ and $c$ aswell as $b$ and $d$.

\end{invariant}


The method inputEqs takes a path in the congruence structure and returns the input equations that were used to derive the equality between the first and the last node of the path.
Therefore, after the input of a sequence equations using the addEquation method, the statement $inputEqs(explain(s,t,g),g)$ returns an explanation for $s = t$.

\input{chapters/congruence/algorithms/inputeqs}

%Both structures use the same set of labels $\mathcal{L}$, which is defined inductively.
%\begin{align*}
  %\mathcal{L}_0 &= \{(e,\emptyset) \mid e \in \mathcal{T} \times \mathcal{T}\} \\
  %\mathcal{L}_i &= \{(null,l) \mid l \in 2^{\mathcal{L}_{i-1}}\} \\
  %\mathcal{L} &= \bigcup_{n\in \mathbb{N}} \mathcal{L}_n
%\end{align*}

\subsubsection*{Equation Graph}

A equation graph stores input and deduced equalities in a labeled weighted undirected graph $(V,E)$ with 
$V \subseteq \mathcal{T}$, $E \subseteq V \times \mathcal{E} \times V \times \mathbb{N}$.



\input{chapters/congruence/algorithms/insert_dij}

\input{chapters/congruence/algorithms/explain_dij}

\subsubsection*{Proof Forest}

A proof forest is a collection of proof trees.
A proof tree is a labeled tree with vertices in $\mathcal{T}$ and edge labels in $\mathcal{E}$.

\input{chapters/congruence/algorithms/insert_pt}

See how BarceLogic ppl prove stuff,
-) tree is still tree after inserting
-) path to NCA forms explanation


\subsection*{Proof Production}

\input{chapters/congruence/algorithms/prodproof}

\subsection*{Congruence Compressor}

In Section \ref{TODO} processing of a proof was defined.
The most important kind of proof processing for us is proof compression.
We want to make use of the short explanations found by the congruence closure algorithm described above.
To this end we replace subproofs with new proofs that have shorter conclusions.
Shorter conclusions lead to the need for less resolution steps further down the proof.

The Congruence Compressor does exactly this. It is defined upon the following processing function, specified in pseudocode.

\input{chapters/congruence/algorithms/compressor}