\section*{Congruence closure algorithm}
\label{sec:algorithm}
\SetKwInput{KwGlobal}{Global}
\SetKw{KwInvariant}{Invariant}
\SetKw{KwAssert}{Assert}
The set of extended equations $\mathcal{E} = \mathcal{T} \times \mathcal{T} \cup \{null\}$.

\subsection*{Congruence structure}

A \emph{congruence structure} for set of terms $\mathcal{T}$ is a collection of the following data structures.

\begin{itemize}
	%\item Congruence structure $\langle \mathcal{T}, r,[.], lN, rN, l \rangle$
	\item Representative $r: \mathcal{T} \rightarrow \mathcal{T}$
	\item Congruence class $[.]: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Left neighbours $lN: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Right neighbours $rN: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Lookup table $l: \mathcal{T} \times \mathcal{T} \rightarrow \mathcal{T}$
	\item Congruence graph $g$
	\item Queue $\mathcal{Q}$ of type $\mathcal{T} \times \mathcal{T}$
	\item Current explanations $\mathcal{M}: \mathcal{T} \times \mathcal{T} \rightarrow \mathcal{E}$
\end{itemize}

We call the unique congruence structure for $\mathcal{T} = \emptyset$ the \emph{empty congruence structure}.
Initially $\mathcal{T}$ is empty.
The method \texttt{addNode} enlarges the set of terms.
The updates of $\mathcal{T}$ are not outlined explicitly, but are understood to happen implicitly.
The algorithms below iteratively create new congruence structures from the empty one.
The methods allow to implement congruence structure immutable, see Section \ref{TODO} for details on immutability.

\subsection*{Algorithms}

\input{chapters/congruence/algorithms/addnode}

\input{chapters/congruence/algorithms/addequation}

\input{chapters/congruence/algorithms/merge}

\input{chapters/congruence/algorithms/lazyinsert}

\input{chapters/congruence/algorithms/lazyupdate}

\input{chapters/congruence/algorithms/union}

\begin{invariant}[Congruence class]

For every $s \in \mathcal{T}$, $s \in [r(s)]$
\label{invar:class}
\end{invariant}

\begin{proof}

Clearly the invariant is true when intializing $[s]$ in line \ref{initclass} of addNode.

The only other point in the code that changes $[s]$ is line \ref{changeclass} of union.
Let $v$ and $u$ be the arguments of a call to union.
If $r(s) \neq r(v)$ before the union, then $r(s)$ is not changed and so is $[s]$.
If $r(s) = r(v)$ before the union, then line \ref{changerep} changes $r(s)$ to $r(u)$.
Since by induction $s \in [r(v)]$ before the union, after line \ref{changeclass} holds $s \in [r(u)]$.

\end{proof}

\begin{assertion}[Merge changes]

For $s \in \mathcal{T}$ let $r(s)$ and $r'(s)$ be the representative of $s$ before and after a call to $merge(u,v,eq)$.
Let $S$ be the set of subterms of $s$.
If $r(s) \neq r'(s)$ then there is $t \in sub(s)$ such that $r(t) = r(u)$ or $r(t) = r(v)$.

\end{assertion}

\begin{proof}

Only union changes the representatives after they were initialized.
Union deduces new equations for terms in the lookup table.

\end{proof}

\begin{invariant}[Lookup]

For every congruence structure and for every term $t \in l(\mathcal{T}\times \mathcal{T})$, $t$ is of the form $f(a,b)$ and there are unique terms $u,v$ such that $r(a) = u$, $r(b) = v$ such that $l(u,v) = f(a,b)$

\end{invariant}

\begin{proof}

The values of $l$ are set in line \ref{initl} of \texttt{addNode} and lines \ref{changel1}, \ref{changel2} of \texttt{union}. 
Once they have been set, they do not change anymore.
The correctness of the invariant in line \ref{initl} of \texttt{addNode} follows from Invariant \ref{invar:class}.
Therefore to prove the correctness of the invariant, we have to show that the representatives are updated correctly in a call to \texttt{union} in which lines \ref{changel1}, \ref{changel2} are executed.
Therefore to prove the correctness of the invariant, we have to show that if \texttt{union} initializes $l$
Let $u,v,a,b$ be terms such that $l(u,v) = f(a,b)$.
Suppose that before the union $r(a) = u$ and $r(b) = v$.

Therefore to prove the correctness of the invariant, we have to show that the change of representatives in line \ref{changerep} of \texttt{union} preserves it.

We have to show that 

\end{proof}


\begin{invariant}[Neighbours]

For every $s \in \mathcal{T}$, every $t_r \in rN(r(s))$ and $t_l \in lN(r(s))$, $l$ is defined for $(s,r(t_r))$ and $(r(t_l),s)$.

\end{invariant}

\begin{proposition}[Neighbours holds]

The Neighbours invariant holds in line \ref{invariant:neig_add} of addNode and line \ref{invariant:neig_union} of union.

\end{proposition}

\begin{proof}

For addNode either the 

\end{proof}

\begin{proposition}[Correctness]

Let $\mathcal{C}$ be the congruence structure obtained by adding equations $E = e_1, \ldots, e_n$ to the empty congruence structure.
For every $s,t \in \mathcal{T}$: $E \models s = t$ if and only if $r(s) = r(t)$.

\end{proposition}

\begin{proof}

by induction on n

n = 1

nodes added, no deductions; lN,rN of compound terms empty 

n -> n+1

only union changes datastructs,
only structs of subterms of input eq are changed + representative of same class

\end{proof}

\begin{proposition}[Lookup table]

Let $\mathcal{C} = \langle \mathcal{T},r,[.], lN, rN, l \rangle$ be the congruence structure obtained after adding equations $E = e_1, \ldots, e_n$ to the empty congruence structure.
For every $s,t \in \mathcal{T}: t \in lN(r(s))$ if and only if $l$ is defined for $(r(t),r(s))$.

\end{proposition}

\subsection*{Congruence graph}

To produce explanations, the input equations together with deduced equalities have to be stored in some data structure that supports the production of explanations.
We support two different data structures for this purpose.
Both structures store equations in a labeled graph.
A path in a congruence graph is a sequence of undirected, unweighted, labeled edges in the underlying graph.
The set of labels for both types of graphs is the set of extended equations $\mathcal{E}$.

\begin{invariant}[Paths]

For terms $s, t$ such that $s \neq t$ and a congruence structure with representative function $r$ holds if $r(s) = r(t)$ then there is a path in the congruence graph of the structure between $s$ and $t$

\end{invariant}

\begin{invariant}[Insert]

For every edge in a congruence structure between vertices $u,v$ with label $null$, 
there are $a,b,c,d \in \mathcal{T}$ such that $u = f(a,b)$, $v = f(c,d)$, 
there are paths in the underlying graphs between $a$ and $c$ aswell as $b$ and $d$.

\end{invariant}


The method inputEqs takes a path in the congruence structure and returns the input equations that were used to derive the equality between the first and the last node of the path.
Therefore, after the input of a sequence equations using the addEquation method, the statement $inputEqs(explain(s,t,g),g)$ returns an explanation for $s = t$.

\input{chapters/congruence/algorithms/inputeqs}

%Both structures use the same set of labels $\mathcal{L}$, which is defined inductively.
%\begin{align*}
  %\mathcal{L}_0 &= \{(e,\emptyset) \mid e \in \mathcal{T} \times \mathcal{T}\} \\
  %\mathcal{L}_i &= \{(null,l) \mid l \in 2^{\mathcal{L}_{i-1}}\} \\
  %\mathcal{L} &= \bigcup_{n\in \mathbb{N}} \mathcal{L}_n
%\end{align*}

\subsubsection*{Equation Graph}

A equation graph stores input and deduced equalities in a labeled weighted undirected graph $(V,E)$ with 
$V \subseteq \mathcal{T}$, $E \subseteq V \times \mathcal{E} \times V \times \mathbb{N}$.



\input{chapters/congruence/algorithms/insert_dij}

\input{chapters/congruence/algorithms/explain_dij}

\subsubsection*{Proof Forest}

A proof forest is a collection of proof trees.
A proof tree is a labeled tree with vertices in $\mathcal{T}$ and edge labels in $\mathcal{E}$.

\input{chapters/congruence/algorithms/insert_pt}

See how BarceLogic ppl prove stuff,
-) tree is still tree after inserting
-) path to NCA forms explanation


\subsection*{Proof Production}

\input{chapters/congruence/algorithms/prodproof}

\subsection*{Congruence Compressor}

In Section \ref{TODO} processing of a proof was defined.
The most important kind of proof processing for us is proof compression.
We want to make use of the short explanations found by the congruence closure algorithm described above.
To this end we replace subproofs with new proofs that have shorter conclusions.
Shorter conclusions lead to the need for less resolution steps further down the proof.

The Congruence Compressor does exactly this. It is defined upon the following processing function, specified in pseudocode.

\input{chapters/congruence/algorithms/compressor}