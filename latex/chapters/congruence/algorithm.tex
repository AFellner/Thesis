\section*{Congruence closure algorithm}
\label{sec:algorithm}
\SetKwInput{KwGlobal}{Global}
\SetKw{KwInvariant}{Invariant}
\SetKw{KwAssert}{Assert}

In this section, we will present a congruence closure algorithm that is able to produce explanations.
The algorithm is a mix of the approaches of the algorithms presented in \cite{Fontaine2004} and \cite{Nieuwenhuis2005,Nieuwenhuis2007}.
The basic structure of the algorithm is inherited from \cite{Fontaine2004}, which itself inherits its structure from the algorithm of Nelson and Oppen \cite{Nelson1980}.
The technique to store and deduce equations of non constant terms is inspired from \cite{Nieuwenhuis2005,Nieuwenhuis2007}.
Additionally the proof forest structure described below, was proposed by \cite{Nieuwenhuis2005,Nieuwenhuis2007}.

\subsection*{Preliminaries}

Our congruence closure algorithm operates on curried terms.
Curried terms use a single binary function symbol to represent general terms.
More formally let $\mathcal{F}$ be a finite set of functions with a designated binary function symbol $f \in \mathcal{F}$ and let every other function symbol in $\mathcal{F}$ be a constant.
A term w.r.t. a signature of this form is called a \emph{curried term}.

It is possible to uniquely translate a general set of terms $\mathcal{T}^{\Sigma}$ with signature $\Sigma = \langle \mathcal{F},arity \rangle$ into a set of curried terms $\mathcal{T'}^{\Sigma'}$.
$\Sigma'$ is obtained from $\Sigma$ by setting $arity$ to zero for every function symbol in $\mathcal{F}$ and introducing the designated binary function symbol $f$ to $\mathcal{F}$.
The translation of a term $t \in \mathcal{T}^{\Sigma}$ is given in terms of the function $curry$.

$$
curry(t) = \Big\{
\begin{array}{ll}
	t & \text{ if } t \text{ is a constant }\\
	f(\ldots (f(f(g,curry(t_1)),curry(t_2)))\ldots,curry(t_n)) &\text{ if } t = g(t_1,\ldots, t_n)
\end{array}
$$

The idea of currying was introduced by M. Sch\"onfinkel \cite{Schoenfinkel1924} in 1924 and independently by Haskell B. Curry \cite{Curry1958} in 1958, who also lends his name to the concept.
Currying is not restricted to terms.
The general indea is to translate functions of type $A \times B \rightarrow C$ into functions of type $A \rightarrow B \rightarrow C$.
There is a close relation between currying and lambda calculus \cite{Church1936}.
Lambda calculus uses a single binary function $\lambda$.
Its arguments can either be elements of some set or again lambda terms.
For an introduction to lambda calculus, including currying in terms of lambda calculus and its relation to functional programming, see \cite{Barendregt1997}.

The benefit of working with curried terms is an easier and cleaner congruence closure algorithm that runs in optimal time $O(n \log(n))$.

Recently so called abstract congruence closure algorithms have been proposed and shown to be more efficient than traditional approaches \cite{Bachmair2000}.
The idea of abstract congruence closure is to introduce new constants for non constant terms.
Doing so, all of equations the algorithm has to take into account are of the form $c = d$ and $c = f(a,b)$, where $a,b,c,d$ are constants.
This replaces tedious preprocessing steps, for example transformation to a graph of outdegree 2 \cite{Downey1980},that are necessary for other algorithms to achieve the optimal running time.

Our method is does not employ the idea of abstract congruence closure.
We found that using currying is enough to obtain an algorithm with optimal running time and no tedious preprocessing steps.
The reason why we did not go for abstract congruence closure is, that we do not want to have the overhead of introducing and eliminating fresh constants.
In the context of proof compression, our congruence closure algorithm will be applied to relatively small instances very often.
We could introduce the extra constants for the whole proof before processing, but would still have to remove them from explanations every time we produce a new subproof.
It would be interesting to investigate, whether our intuition in that regard is right, or if it pays off to deal with extra constants.

Comming back to the explanation producing congruence closure algorithms that inspired ours, \cite{Nieuwenhuis2005,Nieuwenhuis2007} describes an abstract one using currying.
\cite{Fontaine2004} uses a traditional algorithm without currying and extra constants.
Our algorithm is a middle ground between them.

\subsection*{Congruence structure}

A \emph{congruence structure} for set of terms $\mathcal{T}$ is a collection of the following data structures.

\begin{itemize}
	%\item Congruence structure $\langle \mathcal{T}, r,[.], lN, rN, l \rangle$
	\item Representative $r: \mathcal{T} \rightarrow \mathcal{T}$
	\item Congruence class $[.]: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Left neighbours $lN: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Right neighbours $rN: \mathcal{T} \rightarrow 2^\mathcal{T}$
	\item Lookup table $l: \mathcal{T} \times \mathcal{T} \rightarrow \mathcal{T}$
	\item Congruence graph $g$
	\item Queue $\mathcal{Q}$ of type $\mathcal{T} \times \mathcal{T}$
	\item Current explanations $\mathcal{M}: \mathcal{T} \times \mathcal{T} \rightarrow \mathcal{E}$
\end{itemize}

We call the unique congruence structure for $\mathcal{T} = \emptyset$ the \emph{empty congruence structure}.
Initially $\mathcal{T}$ is empty.
The method \texttt{addNode} enlarges the set of terms.
The updates of $\mathcal{T}$ are not outlined explicitly, but are understood to happen implicitly.
The algorithms below iteratively create new congruence structures from the empty one.
The methods allow to implement congruence structure immutable, see Section \ref{TODO} for details on immutability.

\subsection*{Algorithms}

\input{chapters/congruence/algorithms/addnode}

\input{chapters/congruence/algorithms/addequation}

\input{chapters/congruence/algorithms/merge}

\input{chapters/congruence/algorithms/lazyinsert}

\input{chapters/congruence/algorithms/lazyupdate}

\input{chapters/congruence/algorithms/union}

\begin{invariant}[Congruence class]

For every $s \in \mathcal{T}$, $s \in [r(s)]$
\label{invar:class}
\end{invariant}

\begin{proof}

Clearly the invariant is true when intializing $[s]$ in line \ref{initclass} of addNode.

The only other point in the code that changes $[s]$ is line \ref{changeclass} of union.
Let $v$ and $u$ be the arguments of a call to union.
If $r(s) \neq r(v)$ before the union, then $r(s)$ is not changed and so is $[s]$.
If $r(s) = r(v)$ before the union, then line \ref{changerep} changes $r(s)$ to $r(u)$.
Since by induction $s \in [r(v)]$ before the union, after line \ref{changeclass} holds $s \in [r(u)]$.

\end{proof}

\begin{assertion}[Merge changes]

For $s \in \mathcal{T}$ let $r(s)$ and $r'(s)$ be the representative of $s$ before and after a call to $merge(u,v,eq)$.
Let $S$ be the set of subterms of $s$.
If $r(s) \neq r'(s)$ then there is $t \in sub(s)$ such that $r(t) = r(u)$ or $r(t) = r(v)$.

\end{assertion}

\begin{proof}

Only union changes the representatives after they were initialized.
Union deduces new equations for terms in the lookup table.

\end{proof}

\begin{invariant}[Lookup]

For every congruence structure and for every term $t \in l(\mathcal{T}\times \mathcal{T})$, $t$ is of the form $f(a,b)$ and there are unique terms $u,v$ such that $r(a) = u$, $r(b) = v$ such that $l(u,v) = f(a,b)$

\end{invariant}

\begin{proof}

The values of $l$ are set in line \ref{initl} of \texttt{addNode} and lines \ref{changel1}, \ref{changel2} of \texttt{union}. 
Once they have been set, they do not change anymore.
The correctness of the invariant in line \ref{initl} of \texttt{addNode} follows from Invariant \ref{invar:class}.
Therefore to prove the correctness of the invariant, we have to show that the representatives are updated correctly in a call to \texttt{union} in which lines \ref{changel1}, \ref{changel2} are executed.
Therefore to prove the correctness of the invariant, we have to show that if \texttt{union} initializes $l$
Let $u,v,a,b$ be terms such that $l(u,v) = f(a,b)$.
Suppose that before the union $r(a) = u$ and $r(b) = v$.

Therefore to prove the correctness of the invariant, we have to show that the change of representatives in line \ref{changerep} of \texttt{union} preserves it.

We have to show that 

\end{proof}


\begin{invariant}[Neighbours]

For every $s \in \mathcal{T}$, every $t_r \in rN(r(s))$ and $t_l \in lN(r(s))$, $l$ is defined for $(s,r(t_r))$ and $(r(t_l),s)$.

\end{invariant}

\begin{proof}

We show the result for the structure $rN$.
The result about $lN$ can be obtained similarly.
Since $rN$ is initialized with the empty set in line \ref{initrN} of addNode, the invariant clearly holds initially.
To show that the invariant holds, modifications it has to be shown that it eventually holds after modifications to $r$ and $rN$.
The structure $l$ is not modified after initialization.
The structure $r$ is modified in line \ref{changerep} of union.
The structure $rN$ is modified in line \ref{modifyrN} of addNode and line \ref{modifyrN2} of union.

Suppose the invariant holds before a call of union and that $b$ is added to $rN(r(u))$ for some term $u$ in line \ref{modifyrN2} of union.
Lines \ref{startrN} to \ref{stoprN} make sure that $l$ is defined for $(r(u),r(b))$
Before the union, $r(b) = r(v)$ and $b \in rN(r(v))$
Every change of $rN$ in line \ref{modifyrN2} of union is predeceeded by a 

\end{proof}

\begin{proposition}[Sound \& Completeness]

Let $\mathcal{C}$ be the congruence structure obtained by adding equations $E = \langle (u_1,v_1), \ldots, (u_n,v_n) \rangle $ to the empty congruence structure.
For every $s,t \in \mathcal{T}$: $E \models s \thickapprox t$ if and only if $r(s) = r(t)$.

\end{proposition}

\begin{proof}

\begin{paragraph}[Completeness]

We show that from $E \models s \thickapprox t$ follows $r(s) = r(t)$ by induction on $n$.

Base case $n=1$: $E \models s \thickapprox t$ implies either $s = t$ or $\{u_1,v_1\} = \{s,t\}$.
In the first case $r(s) = r(t)$ follows trivially. 
The second case follows from the fact that, when $(u_1,v_1)$ is entered, union is called with arguments $s$ and $t$.
After this operation, $r(s) = r(t)$.

Induction hypothesis: For every sequence of equations $E_n$ with $n$ elements and every $s,t \in \mathcal{T}_{E_n}$: $E_n \models s \thickapprox t$ then $r(s) = r(t)$.

Induction step: Let $E = \langle (u_1,v_1), \ldots, (u_{n+1},v_{n+1}) \rangle$ and $E_n = \langle (u_1,v_1), \ldots, (u_n,v_n) \rangle$.
There are two cases: $E_n \models s\thickapprox t$ and $E_n \nvDash s\thickapprox t$.
In the former case, the claim follows from the induction hypothesis.
We still have to show the claim in the latter case.
We write $E \models_n u \thickapprox v$ as an abbreviation for $E_n \nvDash u \thickapprox v$ and $E \models u \thickapprox v$.
We show the claim by induction on the structure of the terms $s$ and $t$.
Base case: $s$ and $t$ are constants and therefore the transitivity axiom was used to derive $E \models_n s \thickapprox t$.
In other words, there are $l$ terms $t_1,\ldot,t_l$ such that $s = t_1$, $t = t_l$ and for all $i = 1,\ldots,l-1: E \models_n t_i \thickapprox t_{i+1}$.
We prove by induction on $l$ that $r(t_1) = r(t_l)$.
Base case $l = 2$. It has to be the case (up to swapping $u_{n+1}$ with $v_{n+1}$, that $E_n \models s \thickapprox u_{n+1}$ and $E_n \models t \thickapprox v_{n+1}$.
Therefore it follows from Invariant Class, that after the call to union for $(u_{n+1},v_{n+1})$ it is the case that $r(t_1) = r(t_2)$.
Suppose that the claim holds for some $l \in \mathbb{N}$.
In the induction step, going from $l$ to $l+1$, the claim follows from a simple application of the transitivity axiom, since $t_1,\ldots,t_l$ and $t_2,\ldots,t_{l+1}$ are both sequences of length $l$.

For the induction step of the outer induction, suppose that $s = f(a,b)$ and $t = f(c,d)$.
There are two cases such that $E \models_n s \thickapprox t$ can be derived.
Using a transitivity chain, the claim can be shown just like in the base case.
Using the congruence axiom, it has to be the case that $E \models_n a \thickapprox c$ and $E \models_n b \thickapprox d$ (in fact one of those can also be the case without the $n$ index).
The terms $a,b,c,d$ are of lower structure than $s$ and $t$.
Therefore it follows by induction, the Invariants Neighbour and Lookup that either line \ref{deduceEq1} or line line \ref{deduceEq2} of union are called.
Subsequently union is called for $s$ and $t$, after which $r(s) = r(t)$ holds.

\end{paragraph}

\begin{paragraph}[Soundness]

For $s = t$ the claim follows trivially.
Therefore we show soundness in case $s \neq t$.
We show that from $r(s) = r(t)$ follows $E \models s \thickapprox t$ by induction on the number of calls $k$ to union induced by adding all equations of $E$ to the empty congruence structure for all $s$ and $t$ that are arguments of some call to union.
The original claim then follows from invariant Class, since only union modifies the $r$ structure.
%Notice that only union modifies $r$ after initialization.
%Therefore the proof investigates the changes made by union and the parameters it is called when adding equations to a congruence structure.

Base case $k = 1$: $r(s) = r(t)$ implies $\{u_1,v_1\} = \{s,t\}$ and $E \models s \thickapprox t$ is trivial.
%Lines \ref{deduceEq1} and \ref{deduceEq2} do not induce any further unions, because no compound terms, that $s$ or $t$ could be a subterm of, are yet inserted in the congruence structure.

%Induction hypothesis: For every sequence of equations $E_n$ with $n$ elements and every $s,t \in \mathcal{T}_{E_n}$: $r(s) = r(t)$ after adding all $n$ equations to the empty congruence structure then $E_n \models s \thickapprox t$.

For every $l < k$, if a set of equations $F$ induces $l$ calls to union, then from $r(s) = r(t)$ follows $F \models s \thickapprox t$ for all terms $s,t$ that are arguments of some call to union.

Induction step: Suppose $E = \langle (u_1,v_1), \ldots, (u_n,v_n) \rangle$ induces $k$ calls to union with arguments $(h_1,g_1),\ldots,(h_k,g_k)$.
The subsequence $E_n = \langle (u_1,v_1), \ldots, (u_{n-1},v_{n-1}) \rangle$ induced the first $l$ calls to union for some $n-1 \leq l < k$.
In other words, adding $(u_n,v_n)$ to the congruence structure induces the calls to union with arguments $(h_{k-l},g_{k-l}),\ldots,(h_k,g_k)$.
Union induces additional union calls in such a way that the arguments of the additional call are on parent terms of the respective original arguments.
Clearly for the first call to union with arguments $(h_{k-l},g_{k-l})$ it is the case that $E \models h_{k-l} \thickapprox g_{k-l}$, because it is an input equation.
The induction hypothesis, Invariants Lookup and Neighbour and lines \ref{startlN} to \ref{stoprN} of union ensure that all pairs $(h_m,g_m)$ are $E$ congruent for all $m = k-l+1,\ldots,k$.

%
%We show the induction step by another induction on $k-l$, i.e. the number of unions induced by adding $(u_n,v_n)$ to the congruence structure.
%Base case $k-l = 1$: Union is called for $(u_n,v_n)$ and the induces no further calls union.
%After the one call to union $r(u_n) = r(v_n)$ and clearly $E \models u_n \thickapprox v_n$.
%The fact that lines \ref{deduceEq1} and \ref{deduceEq2} of union do not induce any further calls to the method, together with the induction hypothesis and the invariants Lookup and Neighbour, imply that $E \models_n s \thickapprox t$ if and only if $s,t = \{u_n,v_n\}$.
%
%Induction step: Suppose adding $(u_n,v_n)$ induces $m$ calls to union with arguments $(h_{k-m},g_{k-m}),\ldots,(h_k,g_k)$.
%The last call to union has to be added 
%
%Adding the equation $(u_{n+1},v_{n+1})$ to the working congruence structure induces a sequence of $l$ calls to union with parameters $(h_1,g_1),\ldots,(h_l,g_l)$

%After initialization of $r$ only union modifies the structure.
%Adding $E$ to the empty congruence structure induces a sequence of calls to union with parameters $(u_1,v_1), \ldots , (u_n,v_n)$.
%We show by induction on $n$, that $E \models v_i \thickapprox u_i$

\end{paragraph}

\end{proof}

\begin{proposition}[Lookup table]

Let $\mathcal{C} = \langle \mathcal{T},r,[.], lN, rN, l \rangle$ be the congruence structure obtained after adding equations $E = e_1, \ldots, e_n$ to the empty congruence structure.
For every $s,t \in \mathcal{T}: t \in lN(r(s))$ if and only if $l$ is defined for $(r(t),r(s))$.

\end{proposition}

\subsection*{Congruence graph}

To produce explanations, the input equations together with deduced equalities have to be stored in some data structure that supports the production of explanations.
We support two different data structures for this purpose.
Both structures store equations in a labeled graph.
A path in a congruence graph is a sequence of undirected, unweighted, labeled edges in the underlying graph.
The set of labels for both types of graphs is the set of extended equations $\mathcal{E}$.

\begin{invariant}[Paths]

For terms $s, t$ such that $s \neq t$ and a congruence structure with representative function $r$ holds if $r(s) = r(t)$ then there is a path in the congruence graph of the structure between $s$ and $t$

\end{invariant}

\begin{invariant}[Insert]

For every edge in a congruence structure between vertices $u,v$ with label $null$, 
there are $a,b,c,d \in \mathcal{T}$ such that $u = f(a,b)$, $v = f(c,d)$, 
there are paths in the underlying graphs between $a$ and $c$ aswell as $b$ and $d$.

\end{invariant}


The method inputEqs takes a path in the congruence structure and returns the input equations that were used to derive the equality between the first and the last node of the path.
Therefore, after the input of a sequence equations using the addEquation method, the statement $inputEqs(explain(s,t,g),g)$ returns an explanation for $s = t$.

\input{chapters/congruence/algorithms/inputeqs}

%Both structures use the same set of labels $\mathcal{L}$, which is defined inductively.
%\begin{align*}
  %\mathcal{L}_0 &= \{(e,\emptyset) \mid e \in \mathcal{T} \times \mathcal{T}\} \\
  %\mathcal{L}_i &= \{(null,l) \mid l \in 2^{\mathcal{L}_{i-1}}\} \\
  %\mathcal{L} &= \bigcup_{n\in \mathbb{N}} \mathcal{L}_n
%\end{align*}

\subsubsection*{Equation Graph}

A equation graph stores input and deduced equalities in a labeled weighted undirected graph $(V,E)$ with 
$V \subseteq \mathcal{T}$, $E \subseteq V \times \mathcal{E} \times V \times \mathbb{N}$.



\input{chapters/congruence/algorithms/insert_dij}

\input{chapters/congruence/algorithms/explain_dij}

\subsubsection*{Proof Forest}

A proof forest is a collection of proof trees.
A proof tree is a labeled tree with vertices in $\mathcal{T}$ and edge labels in $\mathcal{E}$.

\input{chapters/congruence/algorithms/insert_pt}

See how BarceLogic ppl prove stuff,
-) tree is still tree after inserting
-) path to NCA forms explanation


\subsection*{Proof Production}

\input{chapters/congruence/algorithms/prodproof}

\subsection*{Congruence Compressor}

In Section \ref{TODO} processing of a proof was defined.
The most important kind of proof processing for us is proof compression.
We want to make use of the short explanations found by the congruence closure algorithm described above.
To this end we replace subproofs with new proofs that have shorter conclusions.
Shorter conclusions lead to the need for less resolution steps further down the proof.

The Congruence Compressor does exactly this. It is defined upon the following processing function, specified in pseudocode.

\input{chapters/congruence/algorithms/compressor}

The compressor (Algorithm \ref{algo:compressor}) uses the method \texttt{fixNode} to maintain a correct proof.
The method modifies nodes with premises that have earlier been replaced by the compressor. 
Nodes with unchanged premises are not changed.
Let $n$ be a proof node that was derived by resolving $pr_1$ and $pr_2$ using pivot $\ell$.
It assumed that the values $pr_1$, $pr_2$ and $\ell$ are stored together with the node and can be accessed in constant time.
Note that the method returns $p_1$ in case non of the new premises contains the pivot.
We might as well choose $p_2$ to maintain obtain a correct node.

\input{chapters/congruence/algorithms/fixNode}